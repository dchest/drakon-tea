/* Autogenerated with DRAKON Editor 1.11 */
#include "tea.h"


static void DecryptBlock(
    uint32_t *v,
    uint32_t *k
);

static void EncryptBlock(
    uint32_t *v,
    uint32_t *k
);

static uint32_t LoadUint32(
    unsigned char b[4]
);

static void StoreUint32(
    unsigned char dst[4],
    uint32_t n
);

static void DecryptBlock(
    uint32_t *v,
    uint32_t *k
) {
    /* item 32 */
    uint32_t delta = 0x9e3779b9, sum = 0xc6ef3720, i;
    /* item 280001 */
    i = 0;
    
    item_280002:
    if (i < 32) {
        /* item 31 */
        v[1] -= ((v[0]<<4) + k[2]) ^ (v[0] + sum) ^ ((v[0]>>5) + k[3]);
        /* item 33 */
        v[0] -= ((v[1]<<4) + k[0]) ^ (v[1] + sum) ^ ((v[1]>>5) + k[1]);
        /* item 29 */
        sum -= delta;
        /* item 280003 */
        i++;
        goto item_280002;
    } else {
        return;
    }
    
}

static void EncryptBlock(
    uint32_t *v,
    uint32_t *k
) {
    /* item 22 */
    uint32_t delta = 0x9e3779b9, sum = 0, i;
    /* item 180001 */
    i = 0;
    
    item_180002:
    if (i < 32) {
        /* item 19 */
        sum += delta;
        /* item 21 */
        v[0] += ((v[1]<<4) + k[0]) ^ (v[1] + sum) ^ ((v[1]>>5) + k[1]);
        /* item 34 */
        v[1] += ((v[0]<<4) + k[2]) ^ (v[0] + sum) ^ ((v[0]>>5) + k[3]);
        /* item 180003 */
        i++;
        goto item_180002;
    } else {
        return;
    }
    
}

static uint32_t LoadUint32(
    unsigned char b[4]
) {
    /* item 45 */
    return (uint32_t)b[0] | (uint32_t)b[1]<<8 | (uint32_t)b[2]<<16 | (uint32_t)b[3]<<24;
    
}

static void StoreUint32(
    unsigned char dst[4],
    uint32_t n
) {
    /* item 51 */
    dst[0] = n;
    dst[1] = n >> 8;
    dst[2] = n >> 16;
    dst[3] = n >> 24;
    return;
    
}

int DecryptCBC(
    unsigned char *dst,
    unsigned char *src,
    size_t len,
    unsigned char iv[8],
    unsigned char key[16]
) {
    /* item 164 */
    unsigned char padded[8];
    uint32_t v[2], prev[2], tmp[2], k[4];
    int i;
    /* item 139 */
    prev[0] = LoadUint32(&iv[0]);
    prev[1] = LoadUint32(&iv[4]);
    /* item 140 */
    k[0] = LoadUint32(&key[0]);
    k[1] = LoadUint32(&key[4]);
    k[2] = LoadUint32(&key[8]);
    k[3] = LoadUint32(&key[12]);
    
    item_162:
    if (len > 8) {
        /* item 138 */
        v[0] = tmp[0] = LoadUint32(&src[0]);
        v[1] = tmp[1] = LoadUint32(&src[4]);
        
        DecryptBlock(v, k);
        
        StoreUint32(&dst[0], v[0] ^ prev[0]);
        StoreUint32(&dst[4], v[1] ^ prev[1]);
        
        prev[0] = tmp[0];
        prev[1] = tmp[1];
        
        src += 8;
        dst += 8;
        len -= 8;
        goto item_162;
    } else {
    }
    
    /* item 148 */
    if (len == 8) {
        /* item 157 */
        v[0] = LoadUint32(&src[0]);
        v[1] = LoadUint32(&src[4]);
        
        DecryptBlock(v, k);
        
        StoreUint32(&padded[0], v[0] ^ prev[0]);
        StoreUint32(&padded[4], v[1] ^ prev[1]);
    } else {
        goto item_193;
    }
    
    /* item 196 */
    if (padded[7] <= 8) {
        /* item 1890001 */
        i = 0;
    } else {
        goto item_193;
    }
    
    item_1890002:
    if (i < 8 - padded[7]) {
        /* item 190 */
        dst[i] = padded[i];
        /* item 1890003 */
        i++;
        goto item_1890002;
    } else {
        /* item 194 */
        return 0;
    }
    
    item_193:
    return -1;
    
}

void EncryptCBC(
    unsigned char *dst,
    unsigned char *src,
    size_t len,
    unsigned char iv[8],
    unsigned char key[16]
) {
    /* item 109 */
    unsigned char padded[8];
    uint32_t v[2], k[4];
    int i;
    /* item 64 */
    v[0] = LoadUint32(&iv[0]);
    v[1] = LoadUint32(&iv[4]);
    /* item 65 */
    k[0] = LoadUint32(&key[0]);
    k[1] = LoadUint32(&key[4]);
    k[2] = LoadUint32(&key[8]);
    k[3] = LoadUint32(&key[12]);
    
    item_106:
    if (len >= 8) {
        /* item 63 */
        v[0] ^= LoadUint32(&src[0]);
        v[1] ^= LoadUint32(&src[4]);
        
        EncryptBlock(v, k);
        
        StoreUint32(&dst[0], v[0]);
        StoreUint32(&dst[4], v[1]);
        
        src += 8;
        dst += 8;
        len -= 8;
        goto item_106;
    } else {
        /* item 920001 */
        i = 0;
    }
    
    item_920002:
    if (i < len) {
        /* item 93 */
        padded[i] = src[i];
        /* item 920003 */
        i++;
        goto item_920002;
    } else {
        /* item 950001 */
        i = len;
    }
    
    item_950002:
    if (i < 8) {
        /* item 96 */
        padded[i] = 8 - len;
        /* item 950003 */
        i++;
        goto item_950002;
    } else {
        /* item 98 */
        v[0] ^= LoadUint32(&padded[0]);
        v[1] ^= LoadUint32(&padded[4]);
        
        EncryptBlock(v, k);
        
        StoreUint32(&dst[0], v[0]);
        StoreUint32(&dst[4], v[1]);
        return;
    }
    
}

size_t PaddedLength(
    size_t len
) {
    /* item 187 */
    return len + (8 - (len % 8));
    
}

int main(void) {
    /* item 117 */
    unsigned char m[] = "Hello world!";
    unsigned char key[16] = "random secretkey";
    unsigned char iv[8] = "randomiv";
    unsigned char c[sizeof(m)+(8-(sizeof(m)%8))];
    unsigned char d[sizeof(m)];
    int i;
    /* item 197 */
    EncryptCBC(c, m, sizeof(m), iv, key);
    /* item 210 */
    printf("Encrypted: ");
    /* item 1980001 */
    i = 0;
    
    item_1980002:
    if (i < sizeof(c)) {
        /* item 199 */
        printf("%c", c[i]);
        /* item 1980003 */
        i++;
        goto item_1980002;
    } else {
        /* item 201 */
        puts("");
    }
    
    /* item 202 */
    if (DecryptCBC(d, c, sizeof(c), iv, key) != 0) {
        /* item 204 */
        puts("error decrypting");
        return 1;
    } else {
        /* item 205 */
        printf("Decrypted: %s\n", d);
        return 0;
    }
    
}



